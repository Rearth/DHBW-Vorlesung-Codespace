---
title: Informationstechnologie I - Termin 5 Strings (T4SST1005)
tags: Vorlesung
slideOptions:
  transition: fade
  theme: white
---

## Informationstechnologie I - Termin 5: Strings (T4SST1005)

David Waidner

Note:
- Heutiger Fokus: Grundlagen der Textverarbeitung in C#.
- Zuerst: Wiederholung der Methoden-Grundlagen.
- Kern-Thema: Der `string`-Datentyp, dessen Eigenschaften und Methoden.
- Ziel: Souver√§ner Umgang mit Textdaten in C#-Anwendungen.

---

## Wiederholung: Methodendefinition

Methoden sind wiederverwendbare Codebl√∂cke, die eine spezifische Aufgabe ausf√ºhren. Sie strukturieren den Code und erh√∂hen die Wartbarkeit.

**Struktur:** `R√ºckgabetyp Methodenname(Parameterliste)`

```csharp
// Definition einer Methode zur Addition zweier Ganzzahlen.
int Add(int a, int b)
{
    int sum = a + b;
    return sum; // 'return' liefert den berechneten Wert zur√ºck.
}
```

Note:
- Eine Methodendefinition deklariert die Signatur und Implementierung der Methode.
- Die Ausf√ºhrung des Codes im Methodenk√∂rper erfolgt erst bei einem expliziten Aufruf.

---

## Wiederholung: Methodenaufruf und R√ºckgabewert

Die Ausf√ºhrung einer Methode wird durch einen Aufruf initiiert. Der Computer folgt dabei einem pr√§zisen Ablauf.

```csharp
// Die Methode Add muss zuvor definiert worden sein.
int Add(int a, int b) { return a + b; }

// Aufruf der Methode und Zuweisung des R√ºckgabewertes.
int result = Add(5, 3); 
Console.WriteLine(result);
```

**Was passiert hier Schritt f√ºr Schritt?**
1. Der Computer sieht den Aufruf: `Add(5, 3)`.
2. Er "springt" in den Code der `Add`-Methode.
3. Er kopiert die Werte: `a` wird zu `5` und `b` wird zu `3`.
4. Der Code in der Methode wird ausgef√ºhrt: `int sum = 5 + 3;` (also `sum = 8`).
5. Die `return sum;` Anweisung sendet den Wert `8` zur√ºck.
6. Der Computer "ersetzt" den urspr√ºnglichen Aufruf `Add(5, 3)` durch das Ergebnis `8`.
7. Die Zeile liest sich f√ºr den Computer nun so: `int result = 8;`.

Note:
- Bei einem Aufruf wird der Programmfluss zur Methode transferiert.
- Nach Ausf√ºhrung "ersetzt" der `return`-Wert gedanklich den Methodenaufruf an der Aufrufstelle.

---

## Grundlagen: Texte in der Programmierung

Texte sind Folgen von Zeichen. Jede Plattform speichert Zeichen als Zahlen (Codepoints / Codeunits) ‚Äî daf√ºr braucht es eine Codierung.

Note:
- Ein Zeichensatz ordnet Zeichen Zahlen zu.
- Eine Codierung legt fest, wie diese Zahlen in Bytes gespeichert werden.
- Wichtige Begriffe: Codepoint, Codeunit, Grapheme (sichtbare Zeichen).

---

## ASCII (kurz)

- Ursprung: 7‚ÄëBit, 128 Zeichen (Steuerzeichen + Basis-Latein).
- Begrenzt: enth√§lt keine Umlaute, nicht‚Äëlateinische Schriften oder Emojis.
- Kompatibel: ASCII‚ÄëWerte sind Teil der Unicode‚ÄëTabelle (gleiche Werte 0‚Äì127).

```csharp
// kleines beispiel
char buchstabe = (char)65; // 'A'
Console.WriteLine(buchstabe);
```

Note:
- Gut f√ºr historische/kleine Daten; heute meist durch Unicode ersetzt.
- Beispiel: 'A' = 65 (ASCII und Unicode).

---

## Unicode und C#

- Unicode definiert universelle Codepoints (z. B. U+20AC f√ºr '‚Ç¨').
- Es gibt Encodings: UTF‚Äë8, UTF‚Äë16, UTF‚Äë32.
- C# verwendet intern UTF‚Äë16:
  - char ist ein UTF‚Äë16 Codeunit (16 Bit).
  - string ist eine Folge von UTF‚Äë16‚ÄëCodeunits.
  - Codepoints au√üerhalb der Basic Multilingual Plane (z. B. viele Emojis) werden als Surrogate-Pair (zwei char) gespeichert.

Note:
- Deshalb ist string.Length die Anzahl der UTF‚Äë16‚ÄëCodeunits, nicht notwendigerweise sichtbarer Zeichen.
- F√ºr echte "Grapheme" (Benutzerzeichen) und kulturelle Operationen gibt es System.Globalization.StringInfo.

---

```csharp
// UTF-16 Beispiel
char euro = '\u20AC';        // '‚Ç¨'
string emoji = "üòÄ";
Console.WriteLine(euro);     // ‚Ç¨
Console.WriteLine(emoji);    // üòÄ
Console.WriteLine(emoji.Length); // meist 2 => zwei UTF-16 Codeunits (Surrogate Pair)
```

---

## Codepoint-Notation: U+XXXX

Die Schreibweise "U+20AC" ist die allgemeine Unicode‚ÄëCodepoint-Notation: "U+" gefolgt von einer hexadezimalen Zahl.
- "20AC" ist hexadezimal; in dezimal entspricht das 8364 ‚Üí das Euro‚ÄëSymbol (‚Ç¨).
- In C# verwendet man f√ºr solche Werte Escape‚ÄëSequenzen: '\uXXXX' (4 Hex) f√ºr BMP‚ÄëCodepoints oder '\UXXXXXXXX' (8 Hex) f√ºr Werte > U+FFFF.

Note:
- "U+..." identifiziert ein Unicode‚ÄëZeichen plattformunabh√§ngig.
- F√ºr Zeichen au√üerhalb der Basic Multilingual Plane (z. B. viele Emojis) ben√∂tigt C# entweder ein \U‚ÄëEscape oder ein Surrogate‚ÄëPair in UTF‚Äë16.

```csharp
// Beispiel
char euro = '\u20AC';         // U+20AC => '‚Ç¨'
string grin = "\U0001F600";   // U+1F600 => üòÄ (ben√∂tigt 8-hex Escape)
```

---

## Grundlagen: Der Datentyp `char`

Der Datentyp `char` repr√§sentiert ein *einzelnes* Unicode-Zeichen. Literale dieses Typs werden in einfachen Anf√ºhrungszeichen deklariert.

```csharp
char buchstabe = 'A';
char ziffer = '9';
char euroSymbol = '‚Ç¨';
```

Note:
- `char` ist die fundamentalste Einheit f√ºr Text in C#.
- Er kann Buchstaben, Ziffern, Satz- und Sonderzeichen enthalten.

---

## Grundlagen: Der Datentyp `string`

Der Datentyp `string` repr√§sentiert eine Sequenz von `char`-Werten. Literale werden in doppelten Anf√ºhrungszeichen deklariert.

```csharp
string gruss = "Hallo Welt";
string einzelnesZeichenAlsString = "A";
string leererString = "";
```

Note:
- Ein `string` kann eine beliebige Anzahl von Zeichen enthalten, auch null Zeichen.
- Er ist der zentrale Datentyp f√ºr die Arbeit mit Texten.

---

## Das Konzept der Immutability (Unver√§nderlichkeit)

Ein `string` in C# ist **unver√§nderlich (immutable)**. Ein einmal erstelltes String-Objekt kann nicht mehr modifiziert werden.

- Jede Operation, die einen String scheinbar √§ndert, erzeugt im Hintergrund ein *neues* String-Objekt.

```csharp
string text = "Hallo";
text.ToUpper(); // Erzeugt "HALLO", aber verwirft es sofort wieder.
Console.WriteLine(text); // Gibt weiterhin "Hallo" aus.

string neuerText = text.ToUpper(); // Das neue Objekt wird gespeichert.
Console.WriteLine(neuerText); // Gibt "HALLO" aus.
```

Note:
- Die Unver√§nderlichkeit sorgt f√ºr vorhersagbares Verhalten und Sicherheit.
- Das Ergebnis von String-Methoden muss fast immer einer Variable zugewiesen werden.

---

## `Length`-Eigenschaft und Index-Zugriff `[]`

Die `Length`-Eigenschaft gibt die Gesamtzahl der Zeichen an. Der Zugriff auf einzelne Zeichen erfolgt √ºber einen nullbasierten Index `[]`.

```csharp
string text = "C#-Code"; // text.Length ist 7
// Index:   0123456

char erstesZeichen = text[0];               // Ergibt 'C'
char letztesZeichen = text[text.Length - 1]; // Ergibt 'e'
```
**Achtung:** Ein Zugriff auf einen ung√ºltigen Index f√ºhrt zu einer `IndexOutOfRangeException`.

Note:
- Die nullbasierte Z√§hlung ist ein fundamentales Konzept.
- Das Muster `Length - 1` f√ºr das letzte Element ist universell.

---

## √úbung 1: L√§ngen-Validierung

- **Ziel:** Pr√ºfen, ob eine Eingabe eine erwartete L√§nge hat.
- **Anforderungen:**
    1. Bitten Sie den Benutzer um die Eingabe einer 5-stelligen Postleitzahl.
    2. Pr√ºfen Sie mit der `Length`-Eigenschaft, ob die Eingabe genau 5 Zeichen lang ist.
    3. Geben Sie eine entsprechende Meldung aus ("G√ºltige L√§nge" oder "Ung√ºltige L√§nge").

---

## Iteration √ºber einen String (`foreach`)

Die `foreach`-Schleife ist der einfachste Weg, jedes Zeichen eines Strings zu durchlaufen, ohne sich um Indizes k√ºmmern zu m√ºssen.

```csharp
string text = "Hallo";

foreach (char buchstabe in text)
{
    // In jeder Iteration enth√§lt 'buchstabe' das n√§chste Zeichen.
    Console.WriteLine(buchstabe);
}
```

Note:
- Ideal, wenn Sie jedes Zeichen einmal lesen m√ºssen und dessen Position (Index) nicht relevant ist.
- Einfache Syntax, weniger fehleranf√§llig als manuelle Index-Verwaltung.

---

## Iteration √ºber einen String (`for`)

Eine `for`-Schleife bietet volle Kontrolle √ºber den Iterationsprozess, da sie direkt mit dem Index arbeitet.

```csharp
string text = "C#-Code";

for (int i = 0; i < text.Length; i++)
{
    char aktuellesZeichen = text[i];
    Console.WriteLine($"Index {i}: {aktuellesZeichen}");
}
```
Dies ist notwendig, wenn die Position eines Zeichens f√ºr die Logik relevant ist.

Note:
- Gibt volle Kontrolle √ºber Start, Ende und Schrittweite der Iteration.
- Unverzichtbar, wenn der Index des Zeichens ben√∂tigt wird.

---

## √úbung 2: Vokale z√§hlen

- **Ziel:** Die Anzahl der Vokale (a, e, i, o, u) in einem Text z√§hlen.
- **Anforderungen:**
    1. Lesen Sie einen Text vom Benutzer ein.
    2. Erstellen Sie eine Z√§hlvariable und initialisieren Sie sie mit 0.
    3. Iterieren Sie mit einer `foreach`-Schleife √ºber jedes Zeichen.
    4. Pr√ºfen Sie in der Schleife, ob das aktuelle Zeichen ein Vokal ist (Gro√ü- und Kleinschreibung ignorieren).
    5. Erh√∂hen Sie den Z√§hler, falls es ein Vokal ist, und geben Sie am Ende die Gesamtanzahl aus.

---

## √úbung 3: Palindrom-Pr√ºfung

- **Ziel:** Pr√ºfen, ob ein Wort vorw√§rts wie r√ºckw√§rts gelesen dasselbe ist (z.B. "Anna", "Lagerregal").
- **Anforderungen:**
    1. Lesen Sie ein Wort vom Benutzer ein.
    2. Iterieren Sie mit einer `for`-Schleife nur bis zur Mitte des Wortes (`text.Length / 2`).
    3. Vergleichen Sie in jeder Iteration das Zeichen am Index `i` mit dem Zeichen am spiegelverkehrten Index `text.Length - 1 - i`.
    4. Wenn ein Paar nicht √ºbereinstimmt, ist es kein Palindrom. Geben Sie eine entsprechende Meldung aus und beenden Sie die Pr√ºfung.
    5. Wenn die Schleife durchl√§uft, ist es ein Palindrom.

---

## String-Formatierung: Konkatenation (`+`)

Der `+`-Operator kann Strings verketten (konkatenieren).

```csharp
string vorname = "Max";
string nachname = "Mustermann";

string vollerName = vorname + " " + nachname; // "Max Mustermann"

Console.WriteLine("Benutzer: " + vollerName);
```

Note:
- Einfach und intuitiv f√ºr wenige Verkn√ºpfungen.
- Bei komplexen Strings wird die Interpolation bevorzugt.

---

## √úbung 4: Text umkehren

- **Ziel:** Einen eingegebenen Text Zeichen f√ºr Zeichen umkehren.
- **Anforderungen:**
    1. Lesen Sie einen Text vom Benutzer ein.
    2. Erstellen Sie einen neuen, leeren String f√ºr das Ergebnis.
    3. Iterieren Sie mit einer `foreach`- oder `for`-Schleife √ºber den eingegebenen Text.
    4. F√ºgen Sie in jeder Iteration das aktuelle Zeichen **vor** den bisherigen Ergebnis-String (z.B. `ergebnis = aktuellesZeichen + ergebnis;`).
    5. Geben Sie den umgekehrten String aus.

---

## String-Formatierung: Interpolation (`$`)

String-Interpolation ist der moderne und empfohlene Ansatz. Ein `$` leitet den String ein, Variablen stehen in `{}`.

```csharp
string name = "Anna";
int alter = 28;

string gruss = $"Name: {name}, Alter: {alter}.";

Console.WriteLine(gruss);
```

Note:
- Erh√∂ht die Lesbarkeit, da die finale Struktur im Code sichtbar ist.
- Sollte als Standardmethode zur String-Formatierung verwendet werden.

---

## Methode: `ToUpper()` / `ToLower()`

Gibt eine neue Zeichenkette zur√ºck, in der alle Buchstaben in Gro√ü- bzw. Kleinbuchstaben umgewandelt wurden.

```csharp
string original = "MischText";
string gross = original.ToUpper(); // Ergibt "MISCHTEXT"
string klein = original.ToLower(); // Ergibt "mischtext"
```

Note:
- N√ºtzlich f√ºr Vergleiche, bei denen die Gro√ü-/Kleinschreibung ignoriert werden soll.
- Das Original-Objekt bleibt unver√§ndert.

---

## Methode: `Trim()`

Gibt einen neuen String zur√ºck, bei dem alle f√ºhrenden und nachgestellten Whitespace-Zeichen entfernt wurden.

```csharp
string userInput = "   Wichtige Eingabe   ";
string bereinigt = userInput.Trim(); // Ergibt "Wichtige Eingabe"
```

Note:
- Standardvorgehen zur Bereinigung von Benutzereingaben.
- Verhindert Fehler bei Vergleichen, die durch unsichtbare Zeichen entstehen.

---

## √úbung 5: Eingabe normalisieren

- **Ziel:** Eine Benutzereingabe f√ºr einen Vergleich vorbereiten.
- **Anforderungen:**
    1. Bitten Sie den Benutzer, "Ja" oder "Nein" einzugeben. Erlauben Sie beliebige Gro√ü-/Kleinschreibung und Leerzeichen (z.B. "  jA ").
    2. Nutzen Sie `Trim()` und `ToLower()` an der Eingabe, um sie zu normalisieren.
    3. Vergleichen Sie den normalisierten String mit "ja" oder "nein" und geben Sie eine verst√§ndliche R√ºckmeldung aus.

---

## Methode: `IndexOf()`

Sucht nach dem ersten Vorkommen einer Zeichenkette und gibt deren nullbasierten Startindex zur√ºck. Gibt `-1` zur√ºck, wenn nichts gefunden wird.

```csharp
string text = "Hallo Welt, sch√∂ne Welt!";
int position1 = text.IndexOf("Welt"); // Ergibt 6
int position2 = text.IndexOf("Erde"); // Ergibt -1
```

Note:
- `IndexOf` ist fundamental, um zu pr√ºfen, ob ein Text einen anderen enth√§lt, und wenn ja, wo.
- Der R√ºckgabewert `-1` ist die Konvention f√ºr "nicht gefunden".

---

## Methode: `Substring()`

Extrahiert einen Teilstring aus einem String.

```csharp
string text = "Programmieren";

// Ab Startindex bis zum Ende
string teil1 = text.Substring(8); // Ergibt "ieren"

// Ab Startindex mit einer bestimmten L√§nge
string teil2 = text.Substring(0, 4); // Ergibt "Prog"
```

Note:
- Oft in Kombination mit `IndexOf` verwendet, um dynamisch Textteile zu extrahieren.
- Ein h√§ufiger Anwendungsfall ist das Parsen von strukturierten Daten.

---

## Methode: `Replace()`

Gibt einen neuen String zur√ºck, in dem alle Vorkommen einer Zeichenkette durch eine andere ersetzt wurden.

```csharp
string satz = "Ein guter Tag ist ein sch√∂ner Tag.";
string neuerSatz = satz.Replace("Tag", "Moment"); 
// Ergibt "Ein guter Moment ist ein sch√∂ner Moment."
```

Note:
- N√ºtzlich f√ºr Korrekturen oder Standardisierungen in Texten.
- Denken Sie an die Immutability: Das Ergebnis muss zugewiesen werden.

---

## √úbung 6: Domain extrahieren

- **Ziel:** Aus einer E-Mail-Adresse den Domain-Namen extrahieren.
- **Anforderungen:**
    1. Bitten Sie den Benutzer um die Eingabe einer E-Mail-Adresse.
    2. Finden Sie die Position des `@`-Zeichens mit `IndexOf`.
    3. Nutzen Sie `Substring`, um den Text *nach* dem `@`-Zeichen zu extrahieren.
    4. Geben Sie den extrahierten Domain-Namen aus.

---

## √úbung 7: Text zensieren

- **Ziel:** Ein Wort in einem Satz durch Sternchen ersetzen.
- **Anforderungen:**
    1. Definieren Sie einen Satz, z.B. `"Das ist ein Test, der ein Test ist."`.
    2. Bitten Sie den Benutzer um ein Wort, das zensiert werden soll.
    3. Verwenden Sie `Replace`, um alle Vorkommen des Wortes durch `"****"` zu ersetzen.
    4. Geben Sie das Ergebnis aus.

---

## √úbung 8: Wortz√§hler

- **Ziel:** Die Anzahl der W√∂rter in einem Satz z√§hlen.
- **Anforderungen:**
    1. Lesen Sie einen Satz vom Benutzer ein und bereinigen Sie ihn mit `Trim()`.
    2. Initialisieren Sie einen Z√§hler f√ºr die W√∂rter (z.B. mit 1, wenn der Text nicht leer ist).
    3. Iterieren Sie mit einer Schleife √ºber jedes Zeichen des Satzes.
    4. Erh√∂hen Sie den Z√§hler jedes Mal, wenn Sie ein Leerzeichen `' '` finden.
    5. *Zusatz*: Verhindern Sie, dass mehrere Leerzeichen hintereinander den Z√§hler mehrfach erh√∂hen.

---

## √úbung 9: Passwortanalyse

- **Ziel:** Eine Konsolenanwendung, die ein Passwort nach einfachen Regeln validiert.
- **Anforderungen:**
    1. Lesen Sie ein Passwort von der Konsole ein.
    2. Pr√ºfen Sie folgende Kriterien:
        -   Mindestl√§nge von 8 Zeichen (`Length`).
        -   Vorhandensein von mindestens einer Ziffer.
        -   Vorhandensein von mindestens einem Gro√übuchstaben.
    3. Iterieren Sie hierf√ºr √ºber den String und nutzen Sie Hilfsmethoden wie `char.IsDigit()` und `char.IsUpper()`.
    4. Geben Sie eine aussagekr√§ftige R√ºckmeldung an den Benutzer.